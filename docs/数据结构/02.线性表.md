---
title: 线性表
date: 2022-01-06 11:24:18
titleTag: 原创
permalink: /postgraduate/820/data-struct/linear/
categories: 
  - 考研
  - 820
  - 数据结构
  - 线性表
tags: 
  - 考研
  - 820
  - 数据结构
  - 线性表
author: 
  name: 诚城
  link: https://www.carveybunt.cn/user/profile/
---
**$\color{blue}{\large{\text{定义:}}}$** 由$n(n\geq0)$个`相同类型`的元素组成的`有序集合`。
$$
L=(a_1,a_2,a_3,……a_{n-2},a_{n-1},a_n)
$$
<!-- more -->
1. 线性表汇中元素个数n，称为线性表的长度。当n=0是，为空表。
2. $a_1$是唯一的没有“前驱”数据元素，$a_n$是唯一一个没有"后继"的数据元素。
3. $a_(n-1)$是$a_n$的直接`前驱`，$a_(n+1)$是$a_n$的直接`后继`。
## 线性表特点
1. 元素个数是有限的
2. 元素的数据类型相同
3. 元素在逻辑上是顺序的
## 顺序存储
逻辑上相邻的两个元素在物理位置上也相邻。
::: tip
线性表的顺序存储又称为`顺序表`。
:::
### 顺序存储优缺点
::: note
1. 可以随机存取表中任意一个元素。
   > 根据表头元素地址和元素序号计算出对应元素的地址。
     如：
2. 存储密度高，每个节点只存储数据元素。
:::
::: danger
1. 插入和删除需要操作移动大量元素。
2. 线性表变化较大时，难以确定存储空间的容量
3. 需要分配一整段连续的存储空间，不够灵活，可能产生碎片。
:::
### 时间复杂度
#### 插入元素
1. 最好情况：在表尾插入/删除元素，不需要移动元素，时间复杂度为O(1);
1. 最坏情况：在表头插入/删除元素，所有元素都需要往后移动，时间复杂度为O(n);
2. 平均情况，在插入/删除位置概率均等的情况下，平均移动元素的次数为`n/2`，时间复杂为`O(n)`。
#### 删除元素
1. 最好情况：在表尾删除元素，不需要移动元素，时间复杂度为O(1);
1. 最坏情况：在表头删除元素，所有元素都需要往后移动，时间复杂度为O(n);
2. 平均情况，在删除位置概率均等的情况下，平均移动元素的次数为`(n-1)/2`，时间复杂为`O(n)`。

### 顺序表的动态空间申请
```c
#include <stdio.h>
#include <stdlib.h>

#define InitSize 10 //定义线性表初始化长度，可用于动态申请空间
#define ElementType int //定义线性表元素类型，可用于灵活控制结构体参数数据类型

typedef struct { // 使用 typedef 定义别名时，结构体内无结构体本身指针时，可以省略结构体名称
    ElementType *data; // 使用指针，可动态申请数据内存大小
    int MaxSizes,len;  // 动态空间数值最大容量与当前个数
}Sq; // 结构体别名

int main() {
    Sq S; // 定义结构体变量
    // 动态分配结构体数据存储大小
    S.data = (ElementType*)malloc(sizeof(ElementType)*InitSize);
    return 0;
}
```
### 顺序表增删改查
::: details
使用C++
```c
#include <stdio.h>
#include <stdlib.h>

#define InitSize 100 //定义线性表初始化长度，可用于动态申请空间
#define ElementType int //定义线性表元素类型，可用于灵活控制结构体参数数据类型

typedef struct { // 使用 typedef 定义别名时，结构体内无结构体本身指针时，可以省略结构体名称
    ElementType *data; // 使用指针，可动态申请数据内存大小
    int length;  // 动态空间数值最大容量与当前个数
}SqList; // 结构体别名
// 打印顺序表内所有数据
void printSqList(SqList &L){
    if(L.length ==0){
        printf("暂无数据！");
    } else {
      printf("结构体内容为：");
      for (int i = 0; i < L.length; ++i) {
//        printf("链表第%d个元素值为：%d\n",i+1,L.data[i]);
          printf("%4d",L.data[i]); // 打印到一排，每个数据占4列
      }
      printf("\n");
    }
}
// 顺序表插入，第一个参数为顺序表指针，第二个参数为插入位置，第三个为插入的数据
bool listInsert(SqList &L,int i,ElementType e){ // bool 是c++ 语法，c若向使用，需引入stdbool.h C99
    if (i<1 || i >L.length+1) // 判断插入位置是否合法。
        return false;
    if(L.length >= InitSize) // 超出存储空间
        return false;
    for (int j = L.length; j >=i ; j--) {//从后移动数据元素至插入位置
        L.data[j]=L.data[j-1]; // 数据后移
    }
    L.data[i-1]=e; // 掺入数据，因为数值下标从0开始，所以-1
    L.length++; //增加链表长度
    return true;
}
// 查找数据
int locateElement(SqList L,ElementType e){
    if(L.length ==0)
        return -1;
    for (int i = 0; i < L.length; ++i) {
        if(L.data[i] == e)
            return i+1; // 数值下标从0开始
    }
}

// 更新元素数据
bool editElement(SqList &L,int i,ElementType e){
    if(i<1 || i >L.length+1)// 判断删除位置是否正确
        return false;
    if(L.length == 0) // 结构体中无无数据
        return false;
    L.data[i-1] = e; //更新元素的值
    return true;
}
// 删除顺序表元素
bool deleteElement(SqList &L,int i,ElementType &e){ // 因为要改变e的值，所以这里要&引用
    if(i<1 || i >L.length+1)// 判断删除位置是否正确
        return false;
    if(L.length == 0) // 结构体中无无数据
        return false;
    e = L.data[i-1]; //提取删除的数据
    for (int j = i-1; j < L.length; j++) {
        L.data[j] = L.data[j+1];
    }
    L.length--; //减少结构体长度
    return true;
}

int main() {
    SqList S; // 定义结构体变量
    // 初始化链表空间，动态分配结构体数据存储大小
    S.data = (ElementType*)malloc(sizeof(ElementType)*InitSize);
    S.length=0; // 初始化链表长度
    int tmp=34;

    if(listInsert(S,1,tmp)){
        printSqList(S);
    }else{
        printf("插入失败！\n");
    }

    int locat = locateElement(S,tmp);
    if(locat >= 0 ){
        printf("数据%d在结构体中第%d位！\n",tmp,locat+1);
    }else{
        printf("数据%d不存在结构体中！\n",tmp);
    }

    tmp = 56;
    if(editElement(S,1,tmp)){
        printSqList(S);
    }else{
        printf("更新失败！\n");
    }

    int del;
    if(deleteElement(S,1,del)){
        printSqList(S);
        printf("删除数据：%d 成功！\n",del);
    } else{
        printf("删除失败！\n");
    }
    return 0;
}
```
::: 
## 链式存储
使用链式存储的顺序表，称为`链表`。
- 头指针，链表中第一个结点的存储位置，用来标识单链表。若链表中有头结点，头指针永远指向头结点不论链表是否为空。
- 头结点，在单链表`第一个结点之前`附加的一个结点，主要是为了操作的方便。一般不存储任何数据或存放链表的长度。
    > 有了头结点，对在第一结点前插入和删除第一结点操作就统一了，不需要频繁重置头指针。头结点不是必须的。
### 头插法
从链表头部插入数据。需要一个头指针
::: details
使用C++
```c
#include <stdio.h>
#include <stdlib.h>

#define ElementType int
typedef struct LNode{
    ElementType data; // 存储数据的参数变量，称为数据域
    struct LNode *next; // 结构体自身指针，称为指针域
}LNode,*pLNode;// 结构体别名，结构体指针别名
// lNode 是结构体别名。可以同结构体名称一样，这样在函数中定义结构体变量时就可以直接使用别名，而不必使用 struct LNode
// *pLNode 等价于 struct LNode *
// 链表 头插法 初始化
pLNode InitLNodeHead(pLNode &L){
    L = (pLNode)malloc(sizeof(LNode)); //申请链表空间
    L->next =NULL; // 空链表
    L->data = 0; //链表长度
}
// 头插法
pLNode CreateHead(pLNode &L,ElementType e){ // 因为要改变结构体内容，所以 引用&L
    pLNode t;
    t=(pLNode)malloc(sizeof(LNode)); // 申请新结点数据空间
    t->data = e; // 存储数据
    t->next = L->next; // 新结点指针置空
    L->next = t; // 链接结点，头指针指向新结点地址
    L->data++; // 增加链表长度
}
// 头插法打印链表
void printLNode(pLNode L){
    int len = L->data;
    L = L->next; // 获取指针
    while (L !=NULL){
        printf("%4d",L->data); // 打印数据
        L=L->next; // 指针后移
    }
    printf("\n");
    printf("链表长度为：%d\n",len);
}

// 按位置查找
pLNode localByNum(pLNode P,int i){
    if (!P->next ||i == 0 ){
        return P; //空链时、插入第0个位置
    }
    if(i > P->data){
        return NULL; //超出链表长度
    }
    pLNode temp=P; // 获取头指针
    for (int j = 1; j<= i ; ++j) {
       temp=temp->next;// 指针后移
    }
    return temp;
}
// 按值查找
int localByValue(pLNode P,ElementType e){
    int i=0;
    if (!P->next){
        return i;
    }
    pLNode temp=P; // 获取头指针
    for (int j = 1; j<= P->data ; ++j) {
        temp=temp->next;// 指针后移
        if (temp->data == e){
            i=j;
            break; // 跳出循环
        }
    }
    return i;
}
// 按位置插入数据
bool CreateByLocal(pLNode &L,int i,ElementType e){
    if(i<1){
        return false;
    }
    if (!L->next){ // 空链时直接插入。
        if (CreateHead(L,e)){
            return true;
        }
    } else{
        pLNode temp;
        temp = localByNum(L,i-1);// 后去前一数据的指针
        if(temp){
            pLNode temps;
            temps = (pLNode)malloc(sizeof(LNode));
            temps->data = e; // 存储数据
            temps->next = temp->next; // 后指针转移
            temp->next = temps; // 插入位置指针转移
            L->data++;// 增加链表长度
            return true;
        }
    }
    return false;
}
// 按位置删除数据
bool DeleteByLocal(pLNode &L,int i){
    if(i<1 || !L->next){
        return false;
    }
    pLNode temp;
    temp = localByNum(L,i-1);// 获取对应位置的前指针
    if(temp){
        pLNode temps;
        temps = temp->next; // 获取指针
        temp->next = temps->next; // 链接新指针地址
        free(temps); // 释放空间
        L->data--;// 减少链表长度
        return true;
    }else{
        return false;
    }
}


int main() {
    pLNode L;// 定义结构体变量，用于存储数据
    InitLNodeHead(L);
    int x;
    scanf("%d",&x);
    while (x != 9999){ // 当输入 9999 时结束
        CreateHead(L,x);
        scanf("%d",&x); // 继续读取数据，直到跳出循环
    }
    printLNode(L);

    // 直接头插
    printf("请输入需要插入的数据：\n");
    fflush(stdout);
    scanf("%d",&x);
    CreateHead(L,x);
    printLNode(L);

//    // 按位置查找
    printf("请输入要查找的位置：\n");
    fflush(stdout);
    scanf("%d",&x);
    pLNode finds;
    finds = localByNum(L,x);
    if (finds){
        printf("您查找的第%d个位置的值为：%d\n",x,finds->data);
    }else{
        printf("您查找的第%d个位置位置错误，链表长度为：%d\n",L->data);
    }

    // 按值查找
    printf("请输入要查找的值：\n");
    fflush(stdout);
    scanf("%d",&x);
    x = localByValue(L,x);
    if (x){
        printf("您查找的值在第%d个位置。\n",x);
    }else{
        printf("您查找的不在该链表中。\n",L->data);
    }
    // 指定位置插入数据
    printf("请输入要插入的位置：\n");
    fflush(stdout);
    scanf("%d",&x);
    ElementType i;
    printf("请输入要插入的值：\n");
    fflush(stdout);
    scanf("%d",&i);
    CreateByLocal(L,x,i);
    printLNode(L);

    // 指定位置删除数据
    printf("请输入要删除的位置：\n");
    fflush(stdout);
    scanf("%d",&x);
    while (x != 9999){ // 当输入 9999 时结束
        if (DeleteByLocal(L,x)){
            printLNode(L);
        }else{
            printf("删除失败！！\n");
        }
        printf("请输入要删除的位置：\n");
        fflush(stdout);
        scanf("%d",&x); // 继续读取数据，直到跳出循环
    }
    printLNode(L);

    return 0;
}
```
:::
### 尾插法
从链表尾部插入数据。需要头、尾指针各一个。
::: details
使用C++
```c
#include <stdio.h>
#include <stdlib.h>

#define ElementType int
typedef struct LNode{
    ElementType data; // 存储数据的参数变量，称为数据域
    struct LNode *next; // 结构体自身指针，称为指针域
}LNode,*pLNode;// 结构体别名，结构体指针别名
// lNode 是结构体别名。可以同结构体名称一样，这样在函数中定义结构体变量时就可以直接使用别名，而不必使用 struct LNode
// *pLNode 等价于 struct LNode *
// 链表 尾插法 初始化
pLNode InitLNodeTail(pLNode &H,pLNode &T){
    H = (LNode*)malloc(sizeof(LNode)*1); //申请链表空间
    H->next =NULL; // 空链表
    H->data = 0; //记录链表长度
    T=H; // 空链表,尾指针指向头指针
}
// 链表 尾插法 插入数据
pLNode CreateTail(pLNode &T,ElementType e){ // 因为要改变结构体内容，所以 引用&L
    pLNode t;
    int i=T->data;
    i++;
    t=(pLNode)malloc(sizeof(LNode)); // 申请新结点数据空间
    T->data =e; // 存储数据
    T->next =t; // 尾指针指向新指针
    t->data = i; // 记录链表长度
    t->next = NULL; // 新结点指针置空
    T=t; // 更新尾指针
}
// 尾插法打印链表
void printTailLNode(pLNode L){
    if(L->next ==NULL){
        printf("单链表暂无数据！\n");
    }else{
        int len;
        while (L->next !=NULL){
            printf("%4d",L->data);
            L = L->next;
            len = L->data;
        }
        printf("\n");
        if(L->next ==NULL) {
            int len = L->data;
        }
        printf("单链表长度为：%d\n",len);
    }
}
int main() {
    pLNode Head,Tail;
    Tail = (pLNode)malloc(sizeof(LNode)); // 申请尾结点数据空间
    InitLNodeTail(Head,Tail);
    int y;
    scanf("%d",&y);
    while (y != 9999){ // 当输入 9999 时结束
        CreateTail(Tail,y);
        scanf("%d",&y); // 继续读取数据，直到跳出循环
    }
    printTailLNode(Head);
    printf("请输入需要插入的数据：\n");
    fflush(stdout);
    scanf("%d",&y);
    CreateTail(Tail,y);
    printTailLNode(Head);

    return 0;
}
```
:::
## 双链表