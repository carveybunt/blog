---
title: event and listen
date: 2022-06-21 21:39:02
permalink: /laravel/event_listen/
titleTag: 原创
categories: 
  - 后端
  - 框架
  - laravel
tags: 
  - null
author: 
  name: 诚城
  link: https://github.com/carveybunt
---

## 自动生成事件和监听器

为每个事件和监听器手动创建文件是很麻烦的。相反，将监听器和事件添加到 `app/Providers/EventServiceProvider.php`中，如：

```php
protected $listen = [
        ……
        UserSsoEvent::class=>[
            UserSsoListen::class
        ]
    ];
```

使用 `event:generate Artisan` 命令。此命令将生成 `app/Providers/EventServiceProvider.php` 中列出的、尚不存在的任何事件或侦听器：

```sh
php artisan event:generate
```

缺点：会自动生成在 `app/Providers/` 下。

### 手动生成事件和监听器

使用 `make:event` 以及 `make:listener` 用于生成单个事件和监听器的 `Artisan` 命令：

```sh
php artisan make:event UserSsoEvent

php artisan make:listener UserSsoListen --event=UserSsoEvent

php artisan make:event Api/UserSsoEvent
php artisan make:listener Api/UserSsoListen --event=Api/UserSsoEvent

php artisan make:event Api/Backend/AutoGenerateDefaultRoleEvent
php artisan make:event Api/Backend/AutoGenerateDefaultDepartmentEvent
php artisan make:listener Api/Backend/AutoGenerateDefaultDepartmentListen --event=Api/Backend/AutoGenerateDefaultDepartmentEvent

```

最后还要在将监听器和事件添加到 `EventServiceProvider`中，不如直接使用自动注册！！！

## 定义事件

相当于与模型进行关联。

```php
<?php

namespace App\Events;

use App\Models\User;
use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class UserSsoEvent
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public $user;

    public function __construct(User $user)
    {
        $this->user=$user;
    }

    /**
     * Get the channels the event should broadcast on.
     *
     * @return \Illuminate\Broadcasting\Channel|array
     */
//    public function broadcastOn()
//    {
//        return new PrivateChannel('channel-name');
//    }
}
```

事件类不包含逻辑。它是一个 `App\Models\User` 实例容器。 如果事件对象是使用 `PHP` 的 `SerializesModels` 函数序列化的，事件使用的 `SerializesModels` `trait` 将会优雅地序列化任何 `Eloquent` 模型，比如在使用 队列侦听器。

## 定义监听器

```php
<?php

namespace App\Listeners;

use App\Events\OrderShipped;

class SendShipmentNotification
{
    /**
     * 创建事件监听器
     */
    public function __construct()
    {
        // ...
    }

    /**
     * 处理事件
     */
    public function handle(OrderShipped $event): void
    {
        // 使用 $event->order 来访问订单 ...
    }
}
```
