---
title: 队列
date: 2022-01-13 12:24:36
titleTag: 原创
permalink: /postgraduate/820/data-struct/queue/
categories:
  - 数据结构
  - 队列
  - 循环队列
tags:
  - 数据结构
  - 队列
  - 循环队列
---
『队列』(Queue)，简称「队」，也是一种操作受限的线性表，只允许在表的一端进行插入，表的另一端进行删除。插入操作称为「进队」或「入队」，删除操作称为「出队」或「离队」。`FIFO`(First In First Out)。
> 对头(Front),又称为「队首」。
> 队尾(Rear)
<!-- more -->
## 队列
一般使用`链表`实现。 
## 循环队列
循环队列能存储的数据个数为`队列长度-1`。「队尾(rear)」入队，「对头(front)」出队。一般使用`数组`来实现。

::: details
C++ 语言的循环队列个人案列，请大佬指点。
```c
#include <stdio.h>

#define MaxSize 10
#define ElementType int

typedef struct {
    ElementType data[MaxSize]; // 数组形式实现循环队列
    int front,rear; // 头尾指针以 int 形式表现
}ReQueue;

void InitReQueue(ReQueue &q){
    q.front = q.rear = 0;
}

bool IsEmpty(ReQueue q){
    if(q.front == q.rear){
        return true;
    }
    return false;
}
bool IsFull(ReQueue q){
    if((q.rear+1)%MaxSize == q.front){
        return true;
    }
    return false;
}
void pintfLine(){
    printf("—————————————————————————————————— \n");
}
void clearIO(){
    fflush(stdout);
    fflush(stdin);
}
ElementType EnReQueue(ReQueue &q,ElementType e){
    if(IsFull(q)){
        return NULL;
    }
    q.data[q.rear] =e;
    q.rear=(q.rear+1)%MaxSize;
    return e;
}

void PrintReQueue(ReQueue q){
    if(IsEmpty(q)){
        printf("空队！\n");
    } else{
        printf("队列数据为：\n");
        for (int i = q.front; i < q.rear; ++i) {
            if(i == q.front){
                printf("%4d",q.data[i]);
            }else{
                printf(",%d",q.data[i]);
            }
        }
        printf("\n");
        if(IsFull(q)){
            printf("队满，队长为：%d！\n",q.rear-q.front);
        }
    }
}

ElementType DeReQueue(ReQueue &q){
    if(IsEmpty(q)){
        return NULL;
    }
    ElementType e;
    e=q.data[q.front];
    q.front=(q.front+1)%MaxSize;
    return e;
}

void EnData(ReQueue &q){
    int x;
    printf("请输入插入队尾的数据(输入9999,即可返回首页)：\n");
    clearIO();
    scanf("%d",&x);
    while (x!=9999){
        if(EnReQueue(q,x)){
            printf("循环队列长度为：%4d, 队尾数据为：%d。\n",q.rear-q.front,q.data[q.rear-1]);
        }else{
            printf("插入失败，请重试!");
        }
        pintfLine();
        PrintReQueue(q);
        pintfLine();
        printf("请输入插入队尾的数据(输入9999,即可返回首页)：\n");
        clearIO();
        scanf("%d",&x);
    }
}

void DeData(ReQueue &q){
    char c;
    printf("输入字符'y'或'Y'将进行出队操作，其他字符将返回首页：\n");
    clearIO();
    c = getchar();
    while (c == 'y' || c =='Y'){
        if(DeReQueue(q)){
            printf("循环队列长度为：%4d, 队首数据为：%d。\n",q.rear-q.front,q.data[q.front]);
        }else{
            printf("出队失败，请重试！\n");
        }
        pintfLine();
        PrintReQueue(q);
        pintfLine();
        printf("输入字符'y'或'Y'将进行出队操作，其他字符将返回首页：\n");
        clearIO();
        c = getchar();
    }
}

void Home(ReQueue &q){
    printf("请选择循环队列程序模式(输入对应数字即可)：\n");
    printf("1.入队    2.出队    3.初始化   4.退出\n");
    pintfLine();
    clearIO();
    char x;
    x = getchar();
    while (x != '4'){
        switch (x) {
            case '1':
                EnData(q);
                break;
            case '2':
                DeData(q);
                break;
            case '3':
                InitReQueue(q);
                printf("循环队列以初始化，即将返回首页！\n");
                break;
            default:
                break;
        }
        printf("请选择循环队列程序模式(输入对应数字即可)：\n");
        printf("1.入队    2.出队    3.初始化   4.退出\n");
        pintfLine();
        clearIO();
        x = getchar();
    }
}

int main() {
    ReQueue Q;
    InitReQueue(Q);
    Home(Q);
    printf("程序结束");
    return 0;
}

```
:::