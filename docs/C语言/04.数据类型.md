---
title: 数据类型
date: 2021-12-27 09:02:23
permalink: /postgraduate/820/c/datatype/
categories: 
  - 考研
  - 820
  - C语言
  - 数据类型
tags: 
  - 考研
  - 820
  - C语言
  - 数据类型
author: 
  name: 诚城
  link: https://www.carveybunt.cn/user/profile/
---

## 算术型

### 整数型

* #### int
  
  有符号整型，占 `4个字节` 内存，取值范围：-$2^{31}$~($2^{31}$)-1。$2^{31}$约为21亿。

  > 简写：int i; // 越简单越好，常用

    完整写法：signed int i; //不常用
    

  > 32 位：0000 0000 0000 0000 0000 0000 0000 0000 (最高位为符号位)

  从$2^{0}$加到$2^{31}$，4 个字节，一个字节 8 位二进制。

  > 64 位：0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 (最高位为符号位)

  从$2^{0}$加到$2^{63}$。

* #### short

  短整型 `2字节` ，取值范围：-$2^{15}$~($2^{15}$-1)，即 `-32768~32767` 。
  
  > 简写：short i; // 越简单越好，常用

    完整写法：signed short int i; //不常用
    

* #### long

  长整型， `4字节(32位)，8字节(64位)` , 取值范围：-$2^{31}$~($2^{31}$-1) 或 -$2^{63}$~($2^{63}$-1)

  在 32 位系统下，可以使用 `long long` 定义 8 字节。
* #### unsigned short int

  无符号短整型 `2字节` ，取值范围：0~($2^{16}$-1), 即 `65535` 。
* #### unsigned int

  无符号整型， `4个字节` ，取值范围：0~($2^{32}$-1)。
* #### unsigned long int

  无符号长整型， `4 字节(32 位)` ， `8 字节(64 位)` , 取值范围：0~($2^{32}$-1) 或 0~($2^{64}$-1)。

### 浮点型

* #### float

  单精度浮点型， `4个字节` ，取值范围：`-3.4x$10^{38}$~3.4x$10^{38}$。

* #### double

  双精度浮点型， `8 字节` , 取值范围：`-1.7x$10^{308}$~1.7x$10^{308}$

> 浮点数的标准格式(IEEE754 标准)：

  float(23 位尾数，6~7 位有效数字)，1 位数符，8 位阶码，23 位尾数。
  double(52 位尾数，16 位有效数字)，1 位数符，11 位阶码，52 位尾数。
* long double

### 枚举型 enum

用于数据取值范围有限，且取值全部为整数时。

```c
// 定义枚举变量，并设置参数名字，却没有给出名字对应的值，这是因为枚举值默认从 0 开始，往后逐个加 1（递增）；也就是说，week 中的 Mon、Tues ...... Sun 对应的值分别为 0、1 ...... 6。  
enum week{ Mon, Tues, Wed, Thurs, Fri, Sat, Sun };

// 定义枚举变量，并给参数赋值
enum week{ Mon = 1, Tues = 2, Wed = 3, Thurs = 4, Fri = 5, Sat = 6, Sun = 7 };
// 更为简单的赋值
enum week{ Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun };
```

## 字符型

### char

字符， `1 字节` ，取值范围：-128~127。用 `''` 包裹。打印时使用 `%c` 。

### 字符串

用 `""` 包裹。打印时使用 `%s` 。没有支付串数据类型，所有以字符数组形式定义支付串。
[点击查看 字符数组](#字符数组)

### 字符串操作

以下操作均需要引入头文件 `<string.h>`

* strlen
  > strlen(xx); //获取字符串或字符数组长度。
* strcpy
  > char *strcpy(char *dest, const char *src)
  + dest  指向用于存储复制内容的目标数组。
  + src  要复制的字符串。

  把 `src` 所指向的字符串复制到 d `est` 。  
  

```c
  #include <stdio.h>
  #include <string.h>
  
  int main ()
  {
    char src[50], dest[50];
  
    strcpy(src,  "This is source");//赋值
    strcpy(dest, src);
  
    printf("最终的目标字符串： |%s|", dest);
    
    return(0);
  }
  ```

  > strcpy(src, "This is source"); 
* strcat
  > char *strcat(char *dest, const char *src)
  + dest  指向目标数组，该数组包含了一个 C 字符串，`且足够容纳追加后的字符串`。
  + src 指向要追加的字符串，该字符串不会覆盖目标字符串。
  
  把 src 所指向的字符串追加到 dest 所指向的字符串的结尾。
  

```c
  strcat(dest, src);
  ```

* strcmp
  > nt strcmp(const char *str1, const char *str2)

  把 str1 所指向的字符串和 str2 所指向的字符串进行比较。

  该函数返回值如下：

    - 如果返回值小于 0，则表示 str1 小于 str2。
    - 如果返回值大于 0，则表示 str1 大于 str2。
    - 如果返回值等于 0，则表示 str1 等于 str2。
* s

## 指针

指针本质就是 `地址` ！主要用于传递与偏移。取地址操作符 `&` ，也称 `引用` 。取地址操作符 `*` ，也成为 `解引用` 。

::: tip
指针内存大小与系统有关， `32位系统` 指针占 `4字节` ； `64位系统` 指针占 `8字节` 。
:::

### 指针定义与赋值

```c
// 定义无类型指针
viod *p; 
// 定义一个int型指针
int *p;
// 定义一个int型指针w，并将q指针地址赋予w
int q;
int *w=&q; // 实际就是间接访问
```

直接访问，就是直接对变量地址进行存取：

```c
int i=5;
scanf("%d",&i);     // 对变量地址存入数据
printf("%d",i);   // 对变量地址读取数据
return 0;
```

间接访问，即将一个变量地址存放到另一个变量中：

```c
int i=5; // 定义变量并赋值 
int *p=&i; // 定义一个 int 指针，并将变量 i 的地址赋值给指针。
printf(“%d”,*p);      // 结果为5
```

<Badge text="数组名作为实参传递给子函数时，是弱化为指针的。"/>

### 指针传递

#### C指针传递

指针作为形参, 注意此处使用的是 `*` 解引用。

指针作为实参, 在其他函数中进行使用。 `C语言` 需要传入指针 `&` 引用。

```c
#include <stdio.h>
//void change(int **p)子函数修改主函数指针时，二级指针
void change(int *i){ // void 无返回类型函数   形参
    *i = 5; // 解引用
}
int main() {
    int i=10;
    printf("改变前的值：%d\n",i);
    change(&i);// 引用指针    实参
    printf("改变后的值：%d\n",i);
    return 0;
}
```

### C++指针传递

指针作为形参, 注意与 `C语言` 的使用区别， `C语言` 使用的是 `*` 解引用，而 `C++使` 用的是 `&` 引用。

```c
//void change(int *&p)子函数修改主函数指针时
void change(int &p) // 形参
{
  p++;    
}
```

指针作为实参，在其他函数中进行使用。 `C++` 直接传入指针名即可。

```c
change(p); // 实参
```

### 指针偏移

对指针进行加减偏移，偏移大小与指针类型大小有关。

#### C指针偏移

```c
#include <stdio.h>

int main() {
  int i[10]={ 1, 2, 4, 5};
  int *k;
  k = i; // 将 i数组 起始地址传递给 指针K

  for (int j = 0; j < 10; ++j) {
      printf("int数组第%d个值为：%d\n",j, *(k + j));
  }
  return 0;
}
```

指针 自增 自减 偏移的使用：

```c
#include <stdio.h>

int main() {
    int i[5]={ 7, 3, 6, 9},j;
    int *k;
    k = i; // 将 i数组 起始地址传递给 指针K
    j = *k++; // 等价于 j=*k; *k++;
//    j = (*k)++; // 等价于 j=*k; (*k)++;
    printf("j的值为：%d\n",j); // j = 7;
    printf("k自增后的值为：%d\n",*k); // 此时 k =3,指针偏移了
    (*k)++; // 是 k指针所指空间的值自增，不在是指针偏移！！
    printf("(*k)++的值为：%d\n",*k);
    return 0;
}
```

::: danger
注意 `*p++;` 与 `(*p)++` 的区别！！
* `*p++;`是指针偏移，是按指针基类型大小进行内存空间`加减`。
* `(*p)++;`不是指针偏移，是对指针所指向空间的值进行`加减`。
:::

#### C++指针偏移

## 构造类型

### 数组 Array

::: danger
注意访问越界(即访问超出数组长度)。
数组下标从 0 开始。
:::
数组默认有一个值，该值为 `数组起始地址` 。数组作为实参传递给子函数时弱化为[指针](#指针)。

```c
#include <stdio.h>

void change(char *c){
    // 注意以下操作都是字符操作！！！  使用 ''
    *c = 'H'; // 默认指针记为数组第一个值
    c[1] = 'E'; // 数组下标，从0开始
    *(c + 2) = 'L';  // 指针偏移
}

int main() {
    char c[10] = {"welcome!"};
    change(c);
    printf("改变后的内容：%s\n",c);
    puts(c);
    return 0;
}
```

* #### 一维数组
  

```c
  // 未定义数组长度
  int i[];  // 所占内存大小为: 数组长度 * 类型所占内存大小
  char c[]; // 虽然 char 只占 1 个字节，但是内存自动对齐(32位4字节)，所以内存大小为: 4*数组长度，
  // 制定数组长度
  int j[10]; // 所占内存大小为: 10*4
  long long m[10]; // 32位操作系统，所占内存大小为: 10*8
  float j[10]; // 所占内存大小为: 10*4
  double k[10]; // 所占内存大小为: 10*8
  char d[10]; // 内存自动对齐,所占内存大小为: 10*4
  ```

  
* #### 多维数组
  

```c
  // 未定义数组长度
  int i[][];
  char c[][][];
  // 制定数组长度
  int j[10][];
  int k[10][10];
  int l[][10];
  char e[10][];
  char f[10][10];
  char g[][10];
  ```

* #### 字符数组

  必须要比实际字符串长多多一个字节，因为要多一个 `\0` 作为字符数组结尾判断。所以：
  

```c
  // 不得操过数组长度
  char c[5]="abcd";
  printf("%s\n",c);
  printf("%d\n",sizeof(c)); // 打出结果为 5
  char d[5]="ab";
  printf("%s\n",d);
  printf("%d\n",sizeof(d)); // 打出结果为 5
  // 为定义数组的长度
  char e[]="abcdef";
  printf("%s\n",e);
  printf("%d\n",sizeof(e)); // 打出结果为7 实际字符个数+1
  ```

### 结构体 struct

#### 结构体定义

```c
//不含有本身指针的时候，struct后可以不用定义名称，直接起别名即可！！！
typedef struct{ 
   // 结构体内容，包含参数与数据类型
   int data[10];//存储 MaxSize-1 个元素，牺牲一个存储空间用于判断循环队列是否满
   int front,rear;//队列头、尾
}结构体别名; //别名
// 上述结构体内存大小为整型数组大小加上2个指针大小
// 即：4*10+4+4 = 48 字节
```

```c
//含有本身指针的时候，struct后必须定义名称
typedef struct LinkNode{ //结构体名称
    int data;
    struct LinkNode *next;//含有本身指针的时候，struct后必须定义名称
}LinkNode; // 结构体别名，可以与结构体名称一样
// 内存大小为 16??? 为什么
```

```c
typedef struct LNode{
   int data;//定义数据类型
   struct LNode *next; //含有本身指针的时候
}LNode,*pLNode; //结构体别名，结构体指针别名
// 如 pLNode P; sizeof(P)  8字节 ; LNode L;sizeof(L);  16字节
```

#### 结构体的使用

在函数中使用

```c
// 结构体名
LinkNode L;
Ccc C;
// 结构体指针
pLNode N;
```
