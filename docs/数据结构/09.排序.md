---
title: 排序
date: 2022-01-18 16:25:28
titleTag: 原创
permalink: /postgraduate/820/data-struct/sort/
categories:
  - 数据结构
  - 排序
tags:
  - 数据结构
  - 排序
---
将无顺序的数字，按照一定规则进行排序。

分类：插入排序、交换排序、选择排序、归并排序。
<!-- more -->
## 插入排序
## 交换排序
### 冒泡排序
从后往前(或从前往后)两两比较相邻的两个元素大小，将小(或大)值不断迁移，直至最终所有数据按顺序排列。
```c
void swap(ElementType &a, ElementType &b){
    ElementType temp;
    temp = a;
    a=b;
    b=temp;
}
// 冒泡排序
void BubbleSort(ElementType a[], int n){
    int tag;
    for (int i = 0; i < n-1; i++) {
        tag = 0;
        for (int j = n-1; j > 0 ; j--) {
            if(a[j-1] > a[j]){
                swap(a[j-1],a[j]);
            }
            tag=1; // 发生排序改变 标记
        }
        if(tag == 0) // 全部排完，提前结束
            break;
    }
}
```
### 快速排序
利用`分治思想`。以某个值作为标杆，将数组分成2半，然后将新数组各自递归。时间复杂度减一半。
## 选择排序
## 归并排序
## 排序实例
::: datials
```c
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>

typedef int ElementType;
typedef struct{
    ElementType *array; // 存储元素的起始地址
    int length;  // 统计元素个数
}SStable;

void ST_Init(SStable &st){
    st.length = 0;
    st.array = (ElementType *) malloc(sizeof(ElementType)*st.length);
}

void ST_Inits(SStable &st,int length){
    st.length = length;
    st.array = (ElementType *) malloc(sizeof(ElementType)*st.length);
    srand(time(NULL)); // 生成随机数，引入 time.h
    for (int i = 0; i < st.length; i++) {
        st.array[i] = rand()%100; // 生成小于100 的整数
    }
}
void print_ST(SStable &st){
    if(st.length == 0 ){
        printf("暂无数据！\n");
    }
    for (int i = 0; i < st.length; ++i) {
        printf("%4d",st.array[i]);
    }
    printf("\n");
}

void swap(ElementType &a, ElementType &b){
    ElementType temp;
    temp = a;
    a=b;
    b=temp;
}
// 冒泡排序
void BubbleSort(ElementType a[], int n){
    int tag;
    for (int i = 0; i < n-1; i++) {
        tag = 0;
        for (int j = n-1; j > 0 ; j--) {
            if(a[j-1] > a[j]){
                swap(a[j-1],a[j]);
            }
            tag=1; // 发生排序改变 标记
        }
        if(tag == 0) // 全部排完，提前结束
            break;
    }
}
// 快排分割
int Partition(ElementType a[], int left, int right){
    int i,k;
    for (i = k=left; i < right; i++) {
        if(a[i]<a[right]){
            swap(a[i],a[k]);
            k++;
        }
    }
    swap(a[k],a[right]);
    return k;
}
// 快速排序
void QuickSort(ElementType a[],int low,int hight){
    if(low < hight){
        int pivotpos = Partition(a,low,hight);
        QuickSort(a,low,pivotpos-1);
        QuickSort(a,pivotpos+1,hight);
    }
}
int main() {
    SStable ST;
    ElementType A[10];
//    ST_Init(ST);
    ST_Inits(ST,10); //使用随机数
    memcpy(ST.array,A, sizeof(A)); // 复制 整型数组、浮点型数组不能使用 strcpy 只能是用那个 memcpy，一个字节一个字节的复制
    print_ST(ST);
    return 0;
}

```
:::