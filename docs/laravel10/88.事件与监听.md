---
title: event and listen
date: 2022-06-21 21:39:02
permalink: /backend/frame/laravel/event_listen/
titleTag: 原创
categories: 
  - 后端
  - 框架
  - laravel
tags: 
  - null
author: 
  name: 诚城
  link: https://github.com/carveybunt
---

## 自动生成事件和监听器
为每个事件和监听器手动创建文件是很麻烦的。相反，将监听器和事件添加到 `EventServiceProvider`中，如：
```php
protected $listen = [
        ……
        UserSsoEvent::class=>[
            UserSsoListen::class
        ]
    ];
```

使用 `event:generate Artisan` 命令。此命令将生成 `EventServiceProvider` 中列出的、尚不存在的任何事件或侦听器：

```sh
php artisan event:generate
```

### 手动生成事件和监听器

使用 `make:event` 以及 `make:listener` 用于生成单个事件和监听器的 `Artisan` 命令：

```sh
php artisan make:event UserSsoEvent

php artisan make:listener UserSsoListen --event=UserSsoEvent
```

最后还要在将监听器和事件添加到 `EventServiceProvider`中，不如直接使用自动注册！！！

## 定义事件

相当于与模型进行关键。

```php
<?php

namespace App\Events;

use App\Models\User;
use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class UserSsoEvent
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public $user;

    public function __construct(User $user)
    {
        $this->user=$user;
    }

    /**
     * Get the channels the event should broadcast on.
     *
     * @return \Illuminate\Broadcasting\Channel|array
     */
//    public function broadcastOn()
//    {
//        return new PrivateChannel('channel-name');
//    }
}
```
事件类不包含逻辑。它是一个 `App\Models\User` 实例容器。 如果事件对象是使用 `PHP` 的 `SerializesModels` 函数序列化的，事件使用的 `SerializesModels` `trait` 将会优雅地序列化任何 `Eloquent` 模型，比如在使用 队列侦听器。

## 定义监听器
